/*-
 * Copyright (c) 2026
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer
 *    in this position and unchanged.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "test.h"

// tmpdir=$(mktemp -d /tmp/pbzx.XXXXXX)
// cd "$tmpdir"
// printf 'libarchive' \
// 		| xz --lzma2 \
// 		| python3 -c '\
// import sys,struct; \
// d=sys.stdin.buffer.read(); \
// sys.stdout.buffer.write(b"pbzx"+struct.pack(">QQQ",10,10,len(d))+d)' \
// > test.simple.pbzx
// od -t x1 test.simple.pbzx | sed -E -e 's/^0[0-9]+//' | sed -E -e 's/^  //' | sed -E -e 's/( )([0-9a-f]{2})/0x\2,/g;$ D'
static const unsigned char archive_one_block[] = {
	0x70, 0x62, 0x7a, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0xfd, 0x37, 0x7a, 0x58,
	0x5a, 0x00, 0x00, 0x04, 0xe6, 0xd6, 0xb4, 0x46, 0x04, 0xc0, 0x0f, 0x0b, 0x21, 0x01, 0x16, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x3e, 0x01, 0x65, 0x01, 0x00, 0x0a, 0x6c,
	0x69, 0x62, 0x61, 0x72, 0x63, 0x68, 0x69, 0x76, 0x65, 0x0a, 0x00, 0x00, 0x85, 0x94, 0x41, 0x91,
	0x60, 0x3d, 0xd1, 0x60, 0x00, 0x01, 0x2b, 0x0b, 0xca, 0x91, 0x24, 0xc1, 0x1f, 0xb6, 0xf3, 0x7d,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x04, 0x59, 0x5a,
};

DEFINE_TEST(test_read_filter_pbzx)
{
	struct archive_entry *ae;
	struct archive *a;
	char out_buf[16];
	int r;

	assert((a = archive_read_new()) != NULL);
	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_pbzx(a));
	r = archive_read_support_filter_xz(a);
	if (r == ARCHIVE_WARN) {
		skipping("xz reading not fully supported on this platform");
		assertEqualInt(ARCHIVE_OK, archive_read_free(a));
		return;
	}
	assertEqualIntA(a, ARCHIVE_OK, r);
	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_raw(a));
	assertEqualIntA(a, ARCHIVE_OK,
	    archive_read_open_memory(a, archive_one_block,
	        sizeof(archive_one_block)));

	assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));
	assertEqualString("data", archive_entry_pathname(ae));
	assertEqualIntA(a, 10, archive_read_data(a, out_buf, 10));
	assertEqualMem(out_buf, "libarchive", 10);
	assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));

	assertEqualInt(archive_filter_code(a, 0), ARCHIVE_FILTER_XZ);
	assertEqualInt(archive_filter_code(a, 1), ARCHIVE_FILTER_PBZX);
	assertEqualInt(archive_format(a), ARCHIVE_FORMAT_RAW);

	assertEqualInt(ARCHIVE_OK, archive_read_close(a));
	assertEqualInt(ARCHIVE_OK, archive_read_free(a));
}

// tmpdir=$(mktemp -d /tmp/pbzx.XXXXXX)
// cd "$tmpdir"
// printf 'libarchive' | xz --lzma2 > block1.xz
// printf 'pbzxblock2' | xz --lzma2 > block2.xz
// python3 -c '\
// import sys,struct; \
// d1=open("block1.xz","rb").read(); \
// d2=open("block2.xz","rb").read(); \
// sys.stdout.buffer.write(b"pbzx"+struct.pack(">Q",10)+struct.pack(">QQ",10,len(d1))+d1+struct.pack(">QQ",10,len(d2))+d2)' \
// > test.two_blocks.pbzx
// od -t x1 test.two_blocks.pbzx | sed -E -e 's/^0[0-9]+//' | sed -E -e 's/^  //' | sed -E -e 's/( )([0-9a-f]{2})/0x\2,/g;$ D'
static const unsigned char archive_two_blocks[] = {
	0x70, 0x62, 0x7a, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0xfd, 0x37, 0x7a, 0x58,
	0x5a, 0x00, 0x00, 0x04, 0xe6, 0xd6, 0xb4, 0x46, 0x04, 0xc0, 0x0e, 0x0a, 0x21, 0x01, 0x16, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x06, 0x98, 0x25, 0x01, 0x00, 0x09, 0x6c,
	0x69, 0x62, 0x61, 0x72, 0x63, 0x68, 0x69, 0x76, 0x65, 0x00, 0x00, 0x00, 0x95, 0xb6, 0xdf, 0xe4,
	0xd8, 0xda, 0x54, 0x50, 0x00, 0x01, 0x2a, 0x0a, 0x1d, 0x90, 0x38, 0xaf, 0x1f, 0xb6, 0xf3, 0x7d,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x04, 0x59, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0xfd, 0x37, 0x7a, 0x58, 0x5a, 0x00, 0x00, 0x04,
	0xe6, 0xd6, 0xb4, 0x46, 0x04, 0xc0, 0x0e, 0x0a, 0x21, 0x01, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x4a, 0x06, 0x98, 0x25, 0x01, 0x00, 0x09, 0x70, 0x62, 0x7a, 0x78, 0x62,
	0x6c, 0x6f, 0x63, 0x6b, 0x32, 0x00, 0x00, 0x00, 0xbf, 0x2a, 0x98, 0x91, 0x14, 0x9b, 0xb3, 0x96,
	0x00, 0x01, 0x2a, 0x0a, 0x1d, 0x90, 0x38, 0xaf, 0x1f, 0xb6, 0xf3, 0x7d, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x59, 0x5a,
};
DEFINE_TEST(test_read_filter_pbzx_two_blocks)
{
	struct archive_entry *ae;
	struct archive *a;
	char out_buf[24];
	int r;

	assert((a = archive_read_new()) != NULL);
	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_pbzx(a));
	r = archive_read_support_filter_xz(a);
	if (r == ARCHIVE_WARN) {
		skipping("xz reading not fully supported on this platform");
		assertEqualInt(ARCHIVE_OK, archive_read_free(a));
		return;
	}
	assertEqualIntA(a, ARCHIVE_OK, r);
	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_raw(a));
	assertEqualIntA(a, ARCHIVE_OK,
	    archive_read_open_memory(a, archive_two_blocks,
	        sizeof(archive_two_blocks)));

	assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));
	assertEqualString("data", archive_entry_pathname(ae));
	assertEqualIntA(a, 20, archive_read_data(a, out_buf, 20));
	assertEqualMem(out_buf, "libarchivepbzxblock2", 20);
	assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));

	assertEqualInt(archive_filter_code(a, 0), ARCHIVE_FILTER_XZ);
	assertEqualInt(archive_filter_code(a, 1), ARCHIVE_FILTER_PBZX);
	assertEqualInt(archive_format(a), ARCHIVE_FORMAT_RAW);

	assertEqualInt(ARCHIVE_OK, archive_read_close(a));
	assertEqualInt(ARCHIVE_OK, archive_read_free(a));
}


// mkdir -p test/inner; touch test/inner/file.h
// pkgbuild --compression latest --min-os-version 12.0 --root test --identifier test.pkg test.pkg
// xar -xf test.pkg Payload
// od -t x1 Payload | sed -E -e 's/^0[0-9]+//' | sed -E -e 's/^  //' | sed -E -e 's/( )([0-9a-f]{2})/0x\2,/g;$ D'
// Bytes from corentin/Payload (pbzx payload from pkgbuild --compression latest).
static const unsigned char archive_pkg_payload[] = {
	0x70, 0x62, 0x7a, 0x78, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x08, 0xfd, 0x37, 0x7a, 0x58,
	0x5a, 0x00, 0x00, 0x00, 0xff, 0x12, 0xd9, 0x41, 0x03, 0xc0, 0xd3, 0x01, 0x80, 0x08, 0x21, 0x01,
	0x16, 0x00, 0x00, 0x00, 0x3b, 0x24, 0x89, 0xea, 0xe0, 0x03, 0xff, 0x00, 0xcb, 0x5d, 0x00, 0x18,
	0x0d, 0xdf, 0x07, 0xa4, 0x34, 0x7c, 0x7c, 0x50, 0x98, 0x53, 0x8c, 0x90, 0x12, 0x69, 0xd6, 0xfc,
	0x4a, 0xc8, 0x4b, 0x89, 0x14, 0xb9, 0xfe, 0x36, 0x8f, 0x9c, 0x04, 0x32, 0xb4, 0xdd, 0x85, 0xf3,
	0x6f, 0xa0, 0xf0, 0x4f, 0xd4, 0x56, 0xff, 0xe5, 0x66, 0x31, 0xb3, 0x1c, 0x73, 0x5a, 0xef, 0x94,
	0x79, 0x3e, 0xa9, 0xb0, 0xf6, 0x1a, 0x59, 0x25, 0x22, 0xd6, 0xba, 0x55, 0x36, 0xa5, 0xcd, 0x64,
	0x34, 0x06, 0x86, 0x51, 0x9a, 0x23, 0x20, 0xbf, 0xe0, 0xc8, 0x61, 0x73, 0x15, 0x11, 0xed, 0xfc,
	0x86, 0xc5, 0xad, 0x55, 0xc0, 0x9f, 0xf0, 0x91, 0x01, 0x12, 0x5d, 0xae, 0xf5, 0x1d, 0x9e, 0xaf,
	0x72, 0x99, 0x51, 0xd5, 0xbf, 0x27, 0xb6, 0x0f, 0x99, 0x12, 0xe9, 0x0c, 0x9d, 0x7f, 0x82, 0x18,
	0x16, 0x21, 0xb6, 0xb8, 0x96, 0x1e, 0xf8, 0x7d, 0xe8, 0xce, 0xdf, 0xfe, 0xfb, 0xa7, 0x82, 0xdf,
	0x5d, 0xa4, 0x5f, 0xba, 0xf2, 0x4f, 0x83, 0xab, 0xad, 0x1c, 0x0d, 0x5b, 0x2c, 0x2b, 0xb1, 0xff,
	0xe8, 0x8d, 0x4f, 0xe2, 0x4b, 0xfa, 0xb2, 0x65, 0xcf, 0x71, 0x74, 0xc7, 0xac, 0x13, 0x1d, 0x7a,
	0xd9, 0xa3, 0x41, 0x85, 0x66, 0xd8, 0x2d, 0xc6, 0xbd, 0xbc, 0x44, 0xd8, 0x20, 0xcd, 0xdc, 0xa1,
	0x08, 0x3e, 0xa9, 0x32, 0xd9, 0x54, 0x74, 0x64, 0x86, 0x25, 0x1c, 0x95, 0x9a, 0x11, 0x6d, 0xd3,
	0x6e, 0x01, 0x3d, 0x92, 0xa6, 0x57, 0x59, 0xf2, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe3, 0x01,
	0x80, 0x08, 0x00, 0x00, 0xc2, 0x73, 0xaf, 0x8d, 0xa8, 0x00, 0x0a, 0xfc, 0x02, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x59, 0x5a,
};
DEFINE_TEST(test_read_filter_pbzx_pkg_payload)
{
	struct archive_entry *ae;
	struct archive *a;
	int r;

	assert((a = archive_read_new()) != NULL);
	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_pbzx(a));
	r = archive_read_support_filter_xz(a);
	if (r == ARCHIVE_WARN) {
		skipping("xz reading not fully supported on this platform");
		assertEqualInt(ARCHIVE_OK, archive_read_free(a));
		return;
	}
	assertEqualIntA(a, ARCHIVE_OK, r);
	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_cpio(a));
	assertEqualIntA(a, ARCHIVE_OK,
	    archive_read_open_memory(a, archive_pkg_payload,
	        sizeof(archive_pkg_payload)));

	assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));
	assertEqualInt(archive_filter_code(a, 0), ARCHIVE_FILTER_XZ);
	assertEqualInt(archive_filter_code(a, 1), ARCHIVE_FILTER_PBZX);
	assertEqualInt(archive_format(a) & ARCHIVE_FORMAT_CPIO,
	    ARCHIVE_FORMAT_CPIO);

	assertEqualInt(ARCHIVE_OK, archive_read_close(a));
	assertEqualInt(ARCHIVE_OK, archive_read_free(a));
}
